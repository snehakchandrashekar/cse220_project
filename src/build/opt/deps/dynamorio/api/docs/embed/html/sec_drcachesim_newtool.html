---
title: "Creating New Analysis Tools"
layout: default
permalink: /sec_drcachesim_newtool.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Creating New Analysis Tools </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><code>drcachesim</code> provides a <code>drmemtrace</code> analysis tool framework to make it easy to create new trace analysis tools. A new tool should subclass <a class="el" href="namespacedynamorio_1_1drmemtrace.html#aa072932d15fbef2163f1b3704b33abf7">dynamorio::drmemtrace::analysis_tool_t</a>.</p>
<p>Concurrent processing of traces is supported by logically splitting a trace into "shards" which are each processed sequentially. The default shard is a traced application thread, but the tool interface can support other divisions. For tools that support concurrent processing of shards and do not need to see a single time-sorted interleaved merged trace, the interface functions with the parallel_ prefix should be overridden, and parallel_shard_supported() should return true. parallel_shard_init_stream() will be invoked for each shard prior to invoking parallel_shard_memref() for each entry in that shard; the data structure returned from parallel_shard_init() will be passed to parallel_shard_memref() for each trace entry for that shard. The concurrency model used guarantees that all entries from any one shard are processed by the same single worker thread, so no synchronization is needed inside the parallel_ functions. A single worker thread invokes print_results() as well.</p>
<p>For serial operation, process_memref(), operates on a trace entry in a single, sorted, interleaved stream of trace entries. In the default mode of operation, the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ad547a95d14b24aa73a04f43ad600abcc">dynamorio::drmemtrace::analyzer_t</a> class iterates over the trace and calls the process_memref() function of each tool. An alternative mode is supported which exposes the iterator and allows a separate control infrastructure to be built. This alternative mode does not support parallel operation at this time.</p>
<p>Both parallel and serial operation can be supported by a tool, typically by having process_memref() create data on a newly seen traced thread and invoking parallel_shard_memref() to do its work.</p>
<p>For both parallel and serial operation, the function print_results() should be overridden. It is called just once after processing all trace data and it should present the results of the analysis. For parallel operation, any desired aggregation across the whole trace should occur here as well, while shard-specific results can be presented in parallel_shard_exit().</p>
<p>Tools can also perform trace analysis by intervals, e.g. to generate a time series of their results, using the <code>-interval_microseconds</code> option. The generate_interval_snapshot() API allows the tool to create a snapshot of its internal state when a trace interval ends. These snapshots are then passed to the tool in a later print_interval_results() API call where the tool can generate and print results for each trace interval. The length of a trace interval is defined by the <code>-interval_microseconds</code> option, measured using the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ab8531c7f66ccc0d7fe59f436844a295ca5935654bf36c3cb4e813ff0d8397e2ad">dynamorio::drmemtrace::TRACE_MARKER_TYPE_TIMESTAMP</a> marker values. Trace interval analysis is supported also for the parallel mode where the tool implements generate_shard_interval_snapshot() to generate a snapshot for shard-local intervals and the framework automatically combines the shard-local interval snapshots to create the whole-trace interval snapshots, using the tool's combine_interval_snapshots() API.</p>
<p>Today, parallel analysis is only supported for offline traces. Support for online traces may be added in the future.</p>
<p>In the default mode of operation, the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ad547a95d14b24aa73a04f43ad600abcc">dynamorio::drmemtrace::analyzer_t</a> class iterates over the trace and calls the appropriate <a class="el" href="namespacedynamorio_1_1drmemtrace.html#aa072932d15fbef2163f1b3704b33abf7">dynamorio::drmemtrace::analysis_tool_t</a> functions for each tool. An alternative mode is supported which exposes the iterator and allows a separate control infrastructure to be built.</p>
<p>As explained in <a class="el" href="sec_drcachesim_format.html">Trace Format</a>, each trace entry is of type <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ae4a471ed806967b2b6f911b6ef770704">dynamorio::drmemtrace::memref_t</a> and represents one instruction or data reference or a metadata operation such as a thread exit or marker. There are built-in scheduling markers providing the timestamp and cpu identifier on each thread transition. Other built-in markers indicate disruptions in user mode control flow such as signal handler entry and exit.</p>
<p>The absolute ordinals for trace records and instruction fetches are available via the <a class="el" href="classdynamorio_1_1drmemtrace_1_1memtrace__stream__t.html">dynamorio::drmemtrace::memtrace_stream_t</a> interface passed to the initialize_stream() function for serial operation and parallel_shard_init_stream() for parallel operation. If the iterator skips over some records that are not passed to the tools, these ordinals will include those skipped records. If a tool wishes to count only those records or instructions that it sees, it can add its own counters.</p>
<p>In some cases, a tool may want to observe the exact sequence of <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a067f98c2dab7fe5329e2ba248836370e">dynamorio::drmemtrace::trace_entry_t</a> in an offline trace stored on disk. To support such use cases, the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a067f98c2dab7fe5329e2ba248836370e">dynamorio::drmemtrace::trace_entry_t</a> specialization of <a class="el" href="classdynamorio_1_1drmemtrace_1_1analysis__tool__tmpl__t.html">dynamorio::drmemtrace::analysis_tool_tmpl_t</a> and <a class="el" href="classdynamorio_1_1drmemtrace_1_1analyzer__tmpl__t.html">dynamorio::drmemtrace::analyzer_tmpl_t</a> can be used. Specifically, such tools should subclass <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a922f126e20f8a9b2a1d9f2634fcfff0e">dynamorio::drmemtrace::record_analysis_tool_t</a>, and use the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ad80ef1c9a2c9a1465287d240196d48ae">dynamorio::drmemtrace::record_analyzer_t</a> class.</p>
<p>CMake support is provided for including the headers and linking the libraries of the <code>drmemtrace</code> framework. A new CMake function is defined in the DynamoRIO package which sets the include directory for using the <code>drmemtrace/</code> headers:</p>
<div class="fragment"><div class="line">use_DynamoRIO_drmemtrace(mytool)</div>
</div><!-- fragment --><p>The <code>drmemtrace_analyzer</code> library exported by the DynamoRIO package is the main library to link when building a new tool. The tools described above are also exported as the libraries <code>drmemtrace_basic_counts</code>, <code>drmemtrace_view</code>, <code>drmemtrace_opcode_mix</code>, <code>drmemtrace_histogram</code>, <code>drmemtrace_reuse_distance</code>, <code>drmemtrace_reuse_time</code>, <code>drmemtrace_simulator</code>, <code>drmemtrace_func_view</code>, and <code>drmemtrace_syscall_mix</code> and can be created using the <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a948ae300bb9dced06aa82d0b955bd9b7">basic_counts_tool_create()</a>, <a class="el" href="namespacedynamorio_1_1drmemtrace.html#af197d3a54edf9faf2e3c132537dc616d">opcode_mix_tool_create()</a>, <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a8df3e41912b8fec26518cb824505722c">histogram_tool_create()</a>, <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a7b1651c8a97181eb4afe2c45476ce41e">reuse_distance_tool_create()</a>, <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a97b5e872335cb7666b7758a9f50b4579">reuse_time_tool_create()</a>, <a class="el" href="namespacedynamorio_1_1drmemtrace.html#ade00c5d94b488ef28af05c948631ba04">view_tool_create()</a>, <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a2dffb06831f53a2729bbcc6ea52ec53a">cache_simulator_create()</a>, <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a3da86eaf6eb9950958f285c6d1ca4d62">tlb_simulator_create()</a>, func_view_create(), and <a class="el" href="namespacedynamorio_1_1drmemtrace.html#a857fafde359dbe7e32c45f93c317e247">syscall_mix_tool_create()</a> functions.</p>
<h1><a class="anchor" id="sec_drcachesim_sched"></a>
Scheduler</h1>
<p>In addition to the analysis tool framework, which targets running multiple tools at once either in parallel across all traced threads or in a serial fashion, we provide a scheduler which will map inputs to a given set of outputs in a specified manner. This allows a tool such as a core simulator, or just a tool wanting its own control over advancing the trace stream (unlike the analysis tool framework where the framework controls the iteration), to request the next trace record for each output on its own.</p>
<p>Here is a simple example of a single-output, serial stream. This also serves as an example of how to replace the now-removed old analysis tool framework's "external iterator" interface:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacedynamorio_1_1drmemtrace.html#acf6f9e344fed8627ff2868cfa7e34879">scheduler_t</a> scheduler;</div>
<div class="line">std::vector&lt;scheduler_t::input_workload_t&gt; sched_inputs;</div>
<div class="line">sched_inputs.emplace_back(trace_directory);</div>
<div class="line"><span class="keywordflow">if</span> (scheduler.init(sched_inputs, 1, scheduler_t::make_scheduler_serial_options()) !=</div>
<div class="line">    scheduler_t::STATUS_SUCCESS) {</div>
<div class="line">    FATAL_ERROR(<span class="stringliteral">&quot;failed to initialize scheduler: %s&quot;</span>,</div>
<div class="line">                scheduler.get_error_string().c_str());</div>
<div class="line">}</div>
<div class="line"><span class="keyword">auto</span> *stream = scheduler.get_stream(0);</div>
<div class="line"><a class="code" href="namespacedynamorio_1_1drmemtrace.html#ae4a471ed806967b2b6f911b6ef770704">memref_t</a> record;</div>
<div class="line"><span class="keywordflow">for</span> (scheduler_t::stream_status_t status = stream-&gt;next_record(record);</div>
<div class="line">     status != scheduler_t::STATUS_EOF; status = stream-&gt;next_record(record)) {</div>
<div class="line">    <span class="keywordflow">if</span> (status != scheduler_t::STATUS_OK)</div>
<div class="line">        FATAL_ERROR(<span class="stringliteral">&quot;scheduler failed to advance: %d&quot;</span>, status);</div>
<div class="line">    <span class="keywordflow">if</span> (!my_tool-&gt;process_memref(record)) {</div>
<div class="line">        FATAL_ERROR(<span class="stringliteral">&quot;tool failed to process entire trace: %s&quot;</span>,</div>
<div class="line">                    my_tool-&gt;get_error_string().c_str());</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespacedynamorio_1_1drmemtrace_html_acf6f9e344fed8627ff2868cfa7e34879"><div class="ttname"><a href="namespacedynamorio_1_1drmemtrace.html#acf6f9e344fed8627ff2868cfa7e34879">dynamorio::drmemtrace::scheduler_t</a></div><div class="ttdeci">scheduler_tmpl_t&lt; memref_t, reader_t &gt; scheduler_t</div><div class="ttdef"><b>Definition:</b> scheduler.h:1207</div></div>
<div class="ttc" id="anamespacedynamorio_1_1drmemtrace_html_ae4a471ed806967b2b6f911b6ef770704"><div class="ttname"><a href="namespacedynamorio_1_1drmemtrace.html#ae4a471ed806967b2b6f911b6ef770704">dynamorio::drmemtrace::memref_t</a></div><div class="ttdeci">union dynamorio::drmemtrace::_memref_t memref_t</div></div>
<!-- HTML footer for doxygen 1.8.17-->
<!-- start footer part -->
<!--BEGIN GENERATE_TREEVIEW-->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO version 10.0.19656 --- Sat Nov 23 2024 20:39:08 &nbsp; <img border=0 src="favicon.png">
</small></address>
